### 实验报告



首先统计字符串中每个字符出现的频率，编写 `void Huff::getCount(string ss)` 函数。

编码表结构体:

| 字符 | 出现次数 | 编码 |
| ---- | -------- | ---- |
| A    | 3        | 空   |
| X    | 2        | 空   |
| G    | 1        | 空   |

每次将字符与编码表中的字符进行匹配，将匹配到的字符次数+1。

新字符出现时，设置该字符出现次数为1，并添加到编码表中。



下一步是生成哈夫曼树，在 `getHuffTree()` 函数中

![1546690170802](README (2).assets/1546690170802.png)

首先初始化一片森林，其中每棵树都是一个单独的节点，每个节点中保存一个字符信息，左右孩子为空。

然后找到字符次数最少的两棵树，将他们合并，树的根节点是他们的和，把他们作为左右子树，把合并后的树加入森林中，并把原来的两棵树剔除。

重复上一步，直到最后只有一棵树为止，也就是哈夫曼树。



最后生成哈夫曼编码， `getHuffCode()` 。从哈夫曼树的顶部开始向下遍历，遇到左孩子加入字符 '0'，遇到右孩子加入字符 '1'。如果左右孩子均为空，即遇到叶节点，输出字符信息和对应的哈夫曼编码。



程序运行方式: `./main dream.txt` 

随机生成的文件在 random_text.txt

运行结果:![1546690615143](README (2).assets/1546690615143.png)